//--------------------------------------
//--- 010 Editor v5.0.2 Binary Template
//
// File:     mm3cmp.bt
// Author:   Daniel Stien <daniel@stien.org>
// Revision: 2014-12-21
// Purpose:  Midtown Madness 3 car mesh package
//--------------------------------------

typedef enum <uint32> {
    VERSION_109 = 109,
    VERSION_114 = 114,
    VERSION_115 = 115,
} Version;

typedef enum <uint32> {
    NODE_TYPE_TRANSFORM = 0x01,
    NODE_TYPE_MESH1     = 0x02,
    NODE_TYPE_AXIS      = 0x03,
    NODE_TYPE_LIGHT     = 0x04,
    NODE_TYPE_SMOKE     = 0x05,
    NODE_TYPE_MESH2     = 0x06,
} NodeType;

typedef enum <uint16> {
    TriangleList  = 0x6001,
    TriangleStrip = 0x8801,
} PrimitiveType;

typedef struct {
    float x, y, z;
} Vec3f <read=ReadVec3f>;

typedef struct {
    float a, r, g, b;
} Color4f <read=ReadColor4f>;

typedef struct {
    Vec3f v1, v2, v3, v4;
} Mat4x3;

typedef struct {
    Vec3f min, max;
} BoundBox <read=ReadBoundBox>;

typedef struct {
    // D3DVSDT_NORMPACKED3
    int x  : 11; // x  / 1024 * scale
    int y  : 11; // y  / 1024 * scale
    int z  : 10; // z  /  512 * scale
    int nx : 11; // nx / 1024
    int ny : 11; // ny / 1024
    int nz : 10; // nz /  512
    int u  : 11; // u  / 1024
    int v  : 11; // v  / 1024
    int unknown0 : 10;
    uint32 unknown1[3]; // ???, specular
} Vertex <read=ReadVertex>;

typedef struct {
    PrimitiveType type;

    // Triangle list, range of indices in indices list
    // Arguments to DrawIndexedPrimitives()
    if (type == TriangleList) {
        uint16 minIndex;
        uint16 vertexCount;
        uint16 offset;
        uint16 count; // * 3 + 3
    }
    // Triangle strips, range of indices in vertices list
    // Arguments to DrawPrimitives();
    else if (type == TriangleStrip) {
        uint16 offset;
        uint16 count; // + 3
    }

    uint16 unknowns[5];
} Primitive <read=ReadPrimitive>;

typedef struct {
    uint32 minIndex;
    uint32 vertexCount; // Primitive vertex count + 1
    uint32 offset;
    uint32 count; // Primitive count + 1
    ubyte  isTriangleStrip;
    uint32 material; // Index in external material set
} Material <read=ReadMaterial>;

typedef struct {
    uint32 unknown[7];
} NumberPlateVertex;

typedef struct (Version version) {
    uint32    meshSectionLength;

    if (!meshSectionLength) {
        break;
    }

    local int meshSectionStart = FTell();

    float     unknown0; // NAE
    BoundBox  aabb;
    uint32    vertexCount1; // NAE
    uint32    indexCount;
    uint32    unknown1; // NAE
    uint32    unknown2; // NAE
    uint32    unknown3; // NAE

    if (version >= VERSION_115) {
        Color4f   color;
    }
    else {
        float     alpha;
    }

    string    path;

    ubyte    hasIndices;
    if (hasIndices) { // Draw triangles in addition to the vertices.
        uint32    unknown4; // NAE ... or material?
        uint32    indicesLength; // == indexCount * sizeof(uint16)
        uint16    indices[indexCount];
    }

    uint16    unknown5; // Must be > 0
    uint16    unknown6; // NAE
    ubyte     unkonwn7; // NAE
    uint32    vertexCount2;

    if (vertexCount1 != vertexCount2) {
        MessageBox(idOk, "Warning", "vertexCount1 (%u) != vertexCount2 (%u) in '%s'", vertexCount1, vertexCount2, name);
    }

    uint32    vertexStride;
    uint32    verticesLength; // == vertexCount * vertexStride
    uint32    unknown8; // NAE
    Vertex    vertices[vertexCount2];

    uint32    primitiveAndMaterialCount;
    Primitive primitives[primitiveAndMaterialCount / 2]<optimize=false>;

    uint32    materialCount;
    Material  materials[materialCount];

    uint32    hasNumberPlate;
    if (hasNumberPlate) {
        uint32            numberPlateVertexCount;
        NumberPlateVertex numberPlateVertices[numberPlateVertexCount];
    }

    local int meshSectionLeft = meshSectionLength - (FTell() - meshSectionStart);
    if (meshSectionLeft > 0) {
        ubyte     unparsed[meshSectionLeft];
    }
    else if (meshSectionLeft < 0) {
        MessageBox(idOk, "Warning", "Read past meshSectionLength (%d)", meshSectionLeft);
    }
} Mesh;

typedef struct (Version version) {
    ubyte meshFollows;
    if (meshFollows) {
        string path;
        Mesh   mesh(version);
    }
} MeshContainer <read=ReadMeshContainer>;

typedef struct (Version version, NodeType type) {
    uint32 unknown0;
    uint32 unknown1;
    uint32 unknown2;
    uint32 unknown3;

  // Regular cars (MESH1) have body and shadow mesh,
  // ambient cars (MESH2) have body, shadow and lod mesh.
  local int i, maxMeshes = 2;
  if (type == NODE_TYPE_MESH2) {
    maxMeshes = 3;
    BoundBox aabb;
  }

  for (i = 0; i < maxMeshes; i++) {
    MeshContainer meshContainer(version);
    if (!meshContainer.meshFollows) {
      break;
    }
  }
  // TODO: More LOD and material stuff for NODE_TYPE_MESH2 in version 109 files.
} NodeDataMesh;

typedef struct {
    uint32   flags <format=hex>;   // 0x01 = Invisible, 0x04 = Billboard
    Mat4x3   world <open=true>;    // Transformation from root.
    Mat4x3   relative <open=true>; // Transformation from parent.
    Vec3f    unknown0;
    float    unknown1;
} Transformation;

typedef struct {
    Vec3f  unknown0;
    uint32 unknown1;
} RootEntry;

typedef struct (Version version) {
    uint32    unknown0; // Nil
    BoundBox  aabb;
    uint32    unknown1; // 1
    uint16    unknown2; // Nil
    ubyte     unknown3; // 1

    if (version >= VERSION_114) {
        string materialPath;
    }

    Transformation transformation;
    uint32    unknown5;
    ubyte     unknown6;
    BoundBox  aabb2;
    uint32    rootEntryCount;
    uint32    unknown7;
    uint32    unknown8;
    uint32    unknown9;
    float     unknown10[3];
    RootEntry rootEntries[rootEntryCount];
    uint32   meshNodeCount;
} NodeDataRoot;

typedef struct {
    Transformation transformation;
    int32    meshIndex; // -1 if not applicable
    BoundBox aabb; // Axis-aligned bound box relative to parent's transformation.
} NodeDataTransform;

typedef struct (Version version) {
    uint32 unknown0;
    uint32 unknown1;

    if (version >= VERSION_114) {
        float  unknown2[8];
    }
    else {
        float  unknown2[6];
    }
} NodeDataLight;

typedef struct (Version version) {
    NodeType type;
    string   name;

    switch(type) {
        case NODE_TYPE_TRANSFORM:
            NodeDataTransform data;
            break;
        case NODE_TYPE_MESH1:
        case NODE_TYPE_MESH2:
            NodeDataMesh data(version, type);
            break;
        case NODE_TYPE_AXIS:
            break;
        case NODE_TYPE_LIGHT:
            NodeDataLight data(version);
            break;
        case NODE_TYPE_SMOKE:
            uint32 value;
            break;
        default:
            MessageBox(idOk, "Warning", "Unknown type for node '%s': 0x%02X", name, type);
            return;
    }

    // Transform nodes are groups
    if (type == NODE_TYPE_TRANSFORM) {
        uint32 childCount;
        struct Node; // Forward declare
        Node   children(version)[childCount] <optimize=false>;
    }
} Node <read=ReadNode>;

typedef struct {
    uint32  rootNodeId; // == 0
    Version version;
    string  name;
    NodeDataRoot data(version);
    uint32  childCount;
    Node    children(version)[childCount] <optimize=false>;
} RootNode;

RootNode root <open=true>;

// Vec3f summary
string ReadVec3f(Vec3f &v)
{
    string s;
    SPrintf(s, "%f, %f, %f", v.x, v.y, v.z);
    return s;
}

// Color4f summary
string ReadColor4f(Color4f &c)
{
    string s;
    SPrintf(s, "%f, %f, %f, %f", c.a, c.r, c.g, c.b);
    return s;
}

// BoundBox summary
string ReadBoundBox(BoundBox &b)
{
    string s;
    SPrintf(s, "(%f, %f, %f), (%f, %f, %f)", b.min.x, b.min.y, b.min.z, b.max.x, b.max.y, b.max.z);
    return s;
}

// Vertex summary
string ReadVertex(Vertex &v)
{
    string s;
    SPrintf(s, "%d, %d, %d", v.x, v.y, v.z);
    return s;
}

// Primitive summary
string ReadPrimitive(Primitive &p)
{
    string s;
    SPrintf(s, "%s: %d + %d", EnumToString(p.type), p.offset, p.count);
    return s;
}

// Material summary
string ReadMaterial(Material &m)
{
    string s;
    SPrintf(s, "Material %d (%s: %d + %d)", m.material, (m.isTriangleStrip ? EnumToString(TriangleStrip) : EnumToString(TriangleList)), m.offset, m.count);
    return s;
}

// MeshContainer summary
string ReadMeshContainer(MeshContainer &c)
{
    string s;
    SPrintf(s, "'%s'", c.meshFollows ? FileNameGetBase(c.path) : "---");
    return s;
}

// Node summary
string ReadNode(Node &n)
{
    string s;
    SPrintf(s, "%s: '%s'", EnumToString(n.type), n.name);
    return s;
}